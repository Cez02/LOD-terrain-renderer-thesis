#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_atomic_int64 : require

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

#extension GL_EXT_mesh_shader : require

#extension GL_KHR_shader_subgroup_basic : require
#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]


#include "common.h"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Push constants

layout( push_constant ) uniform constants
{
    layout (offset = 64)  vec3 ObservatorPosition;
     uint padding;
     uint MeshletCount;
     uint HeightmapLength;
     uint BaseMeshletOffset;
     float Longitude;
     float Latitude;
     uint8_t LODLevel;

} PushConstants;

// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif

struct RenderStatistics
{
    uint64_t PrimitiveCount;
    uint64_t TaskShaderInvocations;
    uint64_t MeshShaderInvocations;

};

layout(std430, binding = 2) writeonly buffer RenderStats {
    RenderStatistics statistics;
} renderStatistics;

shared int taskShaderInvocations;

// Indexing stuff

uint baseID = gl_WorkGroupID.x;
uint laneID = gl_LocalInvocationID.x;



// Utils

uint LOD_LEVEL;



// Task payload

#define TASK_ITERATIONS MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS

struct MeshletDetails {
    uint quadOffsets[32];
    uint meshletOffset;
    uint LODLevel;
    uint quadCount;
    uint padding;
};

struct Task {
    MeshletDetails meshletDetails[128];

    uint   baseMeshletID;
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    vec3 observatorPosition;

    uint quadCount;

    uint invocationID;
    uint globalID;
    uint workgroupID;
};

taskPayloadSharedEXT Task OUT;


// Mesh shader preparation

void createQuad(uvec2 quadOffset, uint LODStride, MeshletDescription meshlet, uint meshletOffset, inout uint quadCount){

    int keepQuad = int( meshlet.Dimensions.x > quadOffset.x + LODStride && meshlet.Dimensions.y > quadOffset.y + LODStride );

    OUT.meshletDetails[meshletOffset].quadOffsets[quadCount] = uint(quadOffset.x + quadOffset.y * meshlet.Dimensions.x);

    quadCount += keepQuad;
}

vec3 generalMeshletPosition(MeshletDescription meshlet) {
    uint heightmapIndex = meshlet.HeightmapDataOffset;

    vec2 polarOffset = localPolarOffset(meshlet.Offset);
    vec3 vertA = polarToCartesian(OUT.Latitude + polarOffset.y, OUT.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    return vertA;
}

// Core logic

shared uint meshletCounter;

void main() {


    LOD_LEVEL = 1;
    taskShaderInvocations = 0;
    meshletCounter = 0;

    OUT.globalID = gl_GlobalInvocationID.x;
    OUT.workgroupID = gl_WorkGroupID.x;
    OUT.baseMeshletID = PushConstants.BaseMeshletOffset + 32 * baseID;


    OUT.heightmap_length = PushConstants.HeightmapLength;
    OUT.Longitude = PushConstants.Longitude;
    OUT.Latitude = PushConstants.Latitude;
    OUT.observatorPosition = PushConstants.ObservatorPosition;




    memoryBarrierShared();
    barrier();

    atomicAdd(taskShaderInvocations, 1);

    // Pass on data

    uint meshletOffset;
    uint meshletID = PushConstants.BaseMeshletOffset + gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;

    if(meshletID > PushConstants.MeshletCount){
        return;
    }

    MeshletDescription thisMeshlet = meshletDescriptions.descriptions[meshletID];


    // Meshlet culling
    float observerHorizonDistance = observerHorizonDistance(OUT.observatorPosition);
    bool skipMeshlet = shouldCull(thisMeshlet, PushConstants.Latitude, PushConstants.Longitude, 0.0f, PushConstants.ObservatorPosition, observerHorizonDistance);

    bool render = !shouldCull(thisMeshlet, PushConstants.Latitude, PushConstants.Longitude, 0.0f, PushConstants.ObservatorPosition, observerHorizonDistance); // early cull later here on meshlet
    //bool render = true;

    if(!render){
        return;
    }


    meshletOffset = atomicAdd(meshletCounter, 1);
    OUT.meshletDetails[meshletOffset].meshletOffset = uint8_t(gl_LocalInvocationID.x);





    // Choose LOD level

    vec3 meshletPos = generalMeshletPosition(thisMeshlet);
    float dist = length(meshletPos - OUT.observatorPosition);

    LOD_LEVEL = 1 << int(clamp(dist, 0, 800) / 250);
    LOD_LEVEL = clamp(LOD_LEVEL, 1, 8);
    //LOD_LEVEL = 1;

    OUT.meshletDetails[meshletOffset].LODLevel = uint8_t(LOD_LEVEL);


    uint secondMeshletOffset = meshletOffset;


    secondMeshletOffset = atomicAdd(meshletCounter, int(LOD_LEVEL == 1));


    // build LOD mesh

    uint quadCount = 0;
    uint quadCountSecondBuffer = 0;

    uint offsetAccessor[2];
    offsetAccessor[0] = meshletOffset;
    offsetAccessor[1] = secondMeshletOffset;

    uint quadCounterBuffer[2];
    quadCounterBuffer[0] = 0;
    quadCounterBuffer[1] = 0;

    for(uint y = 0; y < MESHLET_LENGTH; y += LOD_LEVEL ){
        for(uint x = 0; x < MESHLET_LENGTH; x += LOD_LEVEL ){

            createQuad(uvec2(x, y), LOD_LEVEL, thisMeshlet, offsetAccessor[quadCounterBuffer[0] / 32], quadCounterBuffer[quadCounterBuffer[0] / 32]);
        }
    }

    quadCount = quadCounterBuffer[0];
    quadCountSecondBuffer = quadCounterBuffer[1];

    OUT.meshletDetails[meshletOffset].quadCount = quadCount;

    OUT.meshletDetails[secondMeshletOffset].LODLevel = OUT.meshletDetails[meshletOffset].LODLevel;
    OUT.meshletDetails[secondMeshletOffset].meshletOffset = OUT.meshletDetails[meshletOffset].meshletOffset;

    OUT.meshletDetails[secondMeshletOffset].quadCount = (int(LOD_LEVEL != 1) * quadCount) +  (int(LOD_LEVEL == 1) * quadCountSecondBuffer);



    memoryBarrierShared();
    barrier();



    if(gl_LocalInvocationID.x == 0){
        atomicAdd(renderStatistics.statistics.TaskShaderInvocations, taskShaderInvocations);
    }

    EmitMeshTasksEXT(meshletCounter, 1, 1);
    //EmitMeshTasksEXT(quadCount, 1, 1);
    return;


}