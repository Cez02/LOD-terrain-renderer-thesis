#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#extension GL_EXT_mesh_shader : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]


#include "common.h"

layout (local_size_x=CMN_MAX_PREFERRED_TASK_WORK_GROUP_INVOCATIONS) in;


// Push constants

layout( push_constant ) uniform constants
{
    layout (offset = 64) uint HeightmapLength;
    uint BaseMeshletOffset;
    float Longitude;
    float Latitude;
    uint LODLevel;
} PushConstants;



// SSBOs

layout(std430, binding = 0) buffer HeightmapData {
    float m_Heights[];
} heightmapData;

layout(std140, binding = 1) buffer MeshletDescriptions {
    MeshletDescription descriptions[];
} meshletDescriptions;


// Indexing stuff

uint baseID = gl_WorkGroupID.x;
uint laneID = gl_LocalInvocationID.x;


// Task payload

#define MAX_MESHLET_SIZE CMN_MAX_MESH_OUTPUT_VERTICES

struct Task {
    uint    meshletID;

    uvec2   baseOffset;
    u8vec2  deltas[MAX_MESHLET_SIZE];
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    uint LODLevel;
};

taskPayloadSharedEXT Task OUT;

// Utils

void main() {
    OUT.meshletID = PushConstants.BaseMeshletOffset + baseID;

    OUT.baseOffset = meshletDescriptions.descriptions[OUT.meshletID].Offset;

    OUT.heightmap_length = PushConstants.HeightmapLength;
    OUT.Longitude = PushConstants.Longitude;
    OUT.Latitude = PushConstants.Latitude;
    OUT.LODLevel = PushConstants.LODLevel;

    UNROLL_LOOP
    for(int i = 0; i<CMN_MESHLET_LENGTH ; i++) {
        UNROLL_LOOP
        for (int j = 0; j < CMN_MESHLET_LENGTH; j++)
        {
            // We set the indexes in accordance with LOD level
            OUT.deltas[i * CMN_MESHLET_LENGTH + j] = u8vec2( min(j * PushConstants.LODLevel, CMN_MESHLET_LENGTH + 1) , min(i * PushConstants.LODLevel, CMN_MESHLET_LENGTH + 1));
        }
    }

    // We only emit as many mesh shaders as we need
    EmitMeshTasksEXT(meshletDescriptions.descriptions[OUT.meshletID].Dimensions.x * meshletDescriptions.descriptions[OUT.meshletID].Dimensions.y, 1, 1);
}