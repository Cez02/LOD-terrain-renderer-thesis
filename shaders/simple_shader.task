#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_atomic_int64 : require

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

#extension GL_EXT_mesh_shader : require

#extension GL_KHR_shader_subgroup_basic : require
#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]


#include "common.h"

layout(local_size_x = MAX_PREFERRED_TASK_WORK_GROUP_INVOCATIONS, local_size_y = 1, local_size_z = 1) in;

// Push constants

layout( push_constant ) uniform constants
{
    layout (offset = 64)  vec3 ObservatorPosition;
    int padding;
     vec3 ObserverLookingDirection;
    uint16_t MeshletCount;
    uint16_t HeightmapLength;
    uint16_t BaseMeshletOffset;
    float Longitude;
    float Latitude;
    uint8_t LODLevel;

} PushConstants;

// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif

struct RenderStatistics
{
    uint64_t PrimitiveCount;
    uint64_t TaskShaderInvocations;
    uint64_t MeshShaderInvocations;

};

layout(std430, binding = 2) writeonly buffer RenderStats {
    RenderStatistics statistics;
} renderStatistics;

shared int taskShaderInvocations;

// Indexing stuff

uint baseID = gl_WorkGroupID.x;
uint laneID = gl_LocalInvocationID.x;



// Utils

uint LOD_LEVEL;



// Task payload

#define TASK_ITERATIONS MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS


struct Task {
    //     (meshletInfoBufferOffset, meshletCount)
    u8vec2 meshShaderProcessingUnits[MESHLETS_PER_TASK_INVOCATION * MAX_PREFERRED_TASK_WORK_GROUP_INVOCATIONS];
    //     (meshletDelta, LODLevel)
    u8vec2 meshletInfoBuffer[MESHLETS_PER_TASK_INVOCATION * MAX_PREFERRED_TASK_WORK_GROUP_INVOCATIONS];


    uint   baseMeshletID;
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    vec3 observatorPosition;

    uint globalMeshletCount, localMeshletOffsetsCount;

};

taskPayloadSharedEXT Task OUT;

shared uint workgroupQuadCount;

// Mesh shader preparation


vec3 generalMeshletPosition(MeshletDescription meshlet) {
    uint heightmapIndex = meshlet.HeightmapDataOffset;

    vec2 polarOffset = localPolarOffset(meshlet.Offset);
    vec3 vertA = polarToCartesian(OUT.Latitude + polarOffset.y, OUT.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    return vertA;
}

// Core logic

shared uint localMeshletInfoBuffers[4][MESHLETS_PER_TASK_INVOCATION * MAX_PREFERRED_TASK_WORK_GROUP_INVOCATIONS];
shared uint meshletCounterPerLOD[4];

shared uint meshletCounter;
shared uint meshShaderProcessingUnitCounter;

void main() {


    LOD_LEVEL = 1;
    taskShaderInvocations = 0;
    meshletCounter = 0;
    meshShaderProcessingUnitCounter = 0;
    workgroupQuadCount = 0;

    meshletCounterPerLOD[0] = 0;
    meshletCounterPerLOD[1] = 0;
    meshletCounterPerLOD[2] = 0;
    meshletCounterPerLOD[3] = 0;

    OUT.heightmap_length = PushConstants.HeightmapLength;
    OUT.Longitude = PushConstants.Longitude;
    OUT.Latitude = PushConstants.Latitude;
    OUT.observatorPosition = PushConstants.ObservatorPosition;

    OUT.baseMeshletID = PushConstants.BaseMeshletOffset + MESHLETS_PER_TASK_INVOCATION * gl_WorkGroupID.x * gl_WorkGroupSize.x;


    memoryBarrierShared();
    barrier();

    atomicAdd(taskShaderInvocations, 1);

    memoryBarrierShared();
    barrier();

    // Pass on data

    UNROLL_LOOP
    for(uint localMeshletOffset = 0; localMeshletOffset < MESHLETS_PER_TASK_INVOCATION; localMeshletOffset++){

        bool skip = false;

        uint meshletID = PushConstants.BaseMeshletOffset + gl_WorkGroupID.x * gl_WorkGroupSize.x * MESHLETS_PER_TASK_INVOCATION + MESHLETS_PER_TASK_INVOCATION * gl_LocalInvocationID.x + localMeshletOffset;


        skip = meshletID >= PushConstants.MeshletCount;
        meshletID = min(meshletID, PushConstants.MeshletCount - 1);


        MeshletDescription thisMeshlet = meshletDescriptions.descriptions[meshletID];


        // Meshlet culling
        float observerHorizonDistance = observerHorizonDistance(OUT.observatorPosition);

        bool render = !shouldCull(thisMeshlet, PushConstants.Latitude, PushConstants.Longitude, 0.0f, PushConstants.ObservatorPosition, observerHorizonDistance, PushConstants.ObserverLookingDirection); // early cull later here on meshlet
        //bool render = true;

        //skip = skip || !render;


        // Choose LOD level

        vec3 meshletPos = generalMeshletPosition(thisMeshlet);
        float dist = length(meshletPos - OUT.observatorPosition);

        uint lod = int(clamp(dist, 0, 800) / 250);
        LOD_LEVEL = 1 << lod;
        LOD_LEVEL = clamp(LOD_LEVEL, 1, 8);
        //LOD_LEVEL = 1;



        // build LOD mesh

        uint meshletOffset = atomicAdd(meshletCounterPerLOD[lod], int(!skip));

        if(!skip){
            localMeshletInfoBuffers[lod][meshletOffset] = uint8_t(gl_LocalInvocationID.x * MESHLETS_PER_TASK_INVOCATION + localMeshletOffset);
        }

    }


    memoryBarrierShared();
    barrier();



    if(gl_LocalInvocationID.x == 0){
        atomicAdd(renderStatistics.statistics.TaskShaderInvocations, taskShaderInvocations);

        OUT.localMeshletOffsetsCount = meshletCounter;
        OUT.globalMeshletCount = PushConstants.MeshletCount;


        // sort the meshlet info buffer

        for(uint8_t lod = 0; lod < 4; lod++){
            for(uint8_t localMeshletDelta = 0; localMeshletDelta < meshletCounterPerLOD[lod]; localMeshletDelta++){
                
                uint meshletBufferDelta = atomicAdd(meshletCounter, 1);

                OUT.meshletInfoBuffer[meshletBufferDelta] = u8vec2(uint8_t(localMeshletInfoBuffers[lod][localMeshletDelta]), uint8_t(1 << lod));


                // check if MSPU has the same LOD as this meshlet

                if (OUT.meshShaderProcessingUnits[meshShaderProcessingUnitCounter].y != 0 &&
                    OUT.meshletInfoBuffer[OUT.meshShaderProcessingUnits[meshShaderProcessingUnitCounter].x].y != (1 << lod)){

                    atomicAdd(meshShaderProcessingUnitCounter, 1);
                }

                // add the meshlet to the MSPU
                OUT.meshShaderProcessingUnits[meshShaderProcessingUnitCounter].meshletCount++;


                // check if MSPU is full
                // lod = 0 -> 1 = 2^0
                // lod = 1 -> 4 = 2^2
                // lod = 2 -> 16 = 2^4
                // lod = 3 -> 64 = 2^6


                if(meshShaderProcessingUnits[meshShaderProcessingUnitCounter].y == (1 << (2*lod))){
                    atomicAdd(meshShaderProcessingUnitCounter, 1);
                }

            }





        }




        EmitMeshTasksEXT(meshletCounter / MESHLETS_PER_MESH_WORKGROUP, 1, 1);
    }


}