#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#extension GL_EXT_mesh_shader : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]


#include "common.h"

layout (local_size_x=MAX_PREFERRED_TASK_WORK_GROUP_INVOCATIONS) in;


// Push constants

layout( push_constant ) uniform constants
{
    layout (offset = 64)  vec3 ObservatorPosition;
     uint padding;
     uint MeshletCount;
     uint HeightmapLength;
     uint BaseMeshletOffset;
     float Longitude;
     float Latitude;
     uint8_t LODLevel;

} PushConstants;


// Uniforms



// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif


// Indexing stuff

uint baseID = gl_WorkGroupID.x;
uint laneID = gl_LocalInvocationID.x;


// Task payload

#define TASK_ITERATIONS MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS

struct Task {
    uint   baseMeshletIDOffset;
    uint   meshletIDLocalOffset[MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS];
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    uint LODLevel;
    vec3 observatorPosition;
};

taskPayloadSharedEXT Task OUT;

// Utils

float PI = 3.1415926;

vec3 polarToCartesian(float lat, float lon, float height){
    float r = 50000 + height * 1 * 50000 / 6371000;
    return vec3( r * cos(lat) * sin(lon),
                 r * sin(lat),
                 r * cos(lat) * cos(lon)
                  );
}

vec2 localPolarOffset(uvec2 offset){
    offset.y = 1200 - offset.y;
    vec2 res = (offset * PI ) / (180 * 1200);
    return res;
}

vec3 generalMeshletPosition(MeshletDescription meshlet) {
    uvec2 vertexOffset = uvec2(0, 0);

    uint heightmapIndex = meshlet.HeightmapDataOffset +  vertexOffset.y * meshlet.Dimensions.x + vertexOffset.x;

    vec2 polarOffset = localPolarOffset(meshlet.Offset + vertexOffset + uvec2(0, 0));
    vec3 vertA = polarToCartesian(OUT.Latitude + polarOffset.y, OUT.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    return vertA;
}

float observerHorizonDistance(){
    float height = length(OUT.observatorPosition) - 50000;

    return sqrt(2 * 50000 * height + height*height);
}

bool shouldCull(uint8_t id) {

    MeshletDescription thisMeshlet = meshletDescriptions.descriptions[OUT.baseMeshletIDOffset + id];

    vec3 meshletPos = generalMeshletPosition(thisMeshlet);

    float dist = length(meshletPos - OUT.observatorPosition);

    return dist > 1.1f * observerHorizonDistance();
}


void main() {

    OUT.baseMeshletIDOffset = PushConstants.BaseMeshletOffset + baseID * MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS;
    OUT.heightmap_length = PushConstants.HeightmapLength;
    OUT.Longitude = PushConstants.Longitude;
    OUT.Latitude = PushConstants.Latitude;
    OUT.LODLevel = PushConstants.LODLevel;
    OUT.observatorPosition = PushConstants.ObservatorPosition;

    int meshletCount = 0;

    //UNROLL_LOOP
    for(uint8_t i = uint8_t(0); i<TASK_ITERATIONS ; i++) {
        // We set the indexes in accordance with LOD level

        if(i >= PushConstants.MeshletCount - OUT.baseMeshletIDOffset)
            continue;

        // meshlet culling
        if(shouldCull(i))
            continue;

        OUT.meshletIDLocalOffset[meshletCount] = i;
        meshletCount++;

    }

    if(OUT.baseMeshletIDOffset >= PushConstants.MeshletCount){
        //EmitMeshTasksEXT(0, 1, 1);
        return;
    }

    //uint meshShadersToEmitt = min(TASK_ITERATIONS, PushConstants.MeshletCount - OUT.baseMeshletIDOffset);
    // We only emit as many mesh shaders as we need
    EmitMeshTasksEXT(meshletCount, 1, 1);
}