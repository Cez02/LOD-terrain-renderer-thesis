#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes: require

#extension GL_EXT_mesh_shader : enable

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#extension GL_EXT_shader_atomic_int64 : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]

#include "common.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(max_vertices=MAX_MESH_OUTPUT_VERTICES, max_primitives=MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;

// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif


struct RenderStatistics
{
    uint64_t PrimitiveCount;
    uint64_t TaskShaderInvocations;
    uint64_t MeshShaderInvocations;

};

layout(std430, binding = 2) writeonly buffer RenderStats {
    RenderStatistics statistics;
} renderStatistics;

shared uint primCounter;
shared uint meshShaderInvocations;

// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input


struct MeshletDetails {
    uint quadOffsets[32];
    uint meshletOffset;
    uint LODLevel;
    uint quadCount;
    uint padding;
};

struct Task {
    MeshletDetails meshletDetails[66];


    uint   baseMeshletID;
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    vec3 observatorPosition;

    uint quadCount;

    uint invocationID;
    uint globalID;
    uint workgroupID;
};

taskPayloadSharedEXT Task IN;



// Indexing stuff

uint meshletID = IN.baseMeshletID + IN.meshletDetails[gl_WorkGroupID.x].meshletOffset;
uint localMeshletOffset = gl_WorkGroupID.x;


uint quadID;


// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    float   wHeight;
    flat  uint meshletID;
    flat uint laneID;
    flat float DistFromObservator;
} OUT[];


// Utils


uvec2 scaledDimensions;


void processVertex(uvec2 vertexOffset, MeshletDescription meshlet, int vertexIndexOffset, inout uint vertexCount, inout bool cull){

    uint vertIndex = vertexIndexOffset + 4 * quadID;

    uint heightmapIndex = meshlet.HeightmapDataOffset + vertexOffset.x + meshlet.Dimensions.x * vertexOffset.y;
    float height = float(int(heightmapData.m_Heights[heightmapIndex]));

    vec3 vertA = vertexToPolarToCartesian(meshlet.Offset + vertexOffset, IN.Latitude, IN.Longitude, height);

    // Interpolants
    OUT[vertIndex].wPos = vertA;
    OUT[vertIndex].wHeight = height;
    OUT[vertIndex].DistFromObservator = 0;
    OUT[vertIndex].meshletID = meshletID;
    OUT[vertIndex].laneID = 0;


    gl_MeshVerticesEXT[vertIndex].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);

    float observerHorizonDistance = observerHorizonDistance(IN.observatorPosition);
    cull = cull && (observerHorizonDistance < length(vertA - IN.observatorPosition));

    vertexCount += 1;

}


void main() {


    quadID = gl_LocalInvocationID.x;
    primCounter = 0;
    meshShaderInvocations = 0;

    bool skip = quadID > IN.meshletDetails[localMeshletOffset].quadCount;


    if(skip){
        return;
    }

    quadID = min(quadID, IN.meshletDetails[localMeshletOffset].quadCount - 1);

    SetMeshOutputsEXT(4 * IN.meshletDetails[localMeshletOffset].quadCount, 2 * IN.meshletDetails[localMeshletOffset].quadCount);

    memoryBarrierShared();
    barrier();

    atomicAdd(meshShaderInvocations, 1);


    // Grab quad data

    MeshletDescription thisMeshlet = meshletDescriptions.descriptions[meshletID];

    uvec2 quadOffset = uvec2(IN.meshletDetails[localMeshletOffset].quadOffsets[quadID] % thisMeshlet.Dimensions.x, IN.meshletDetails[localMeshletOffset].quadOffsets[quadID] / thisMeshlet.Dimensions.x);

    uint quadSize = IN.meshletDetails[localMeshletOffset].LODLevel;


    uint vertCount = 0;
    uint primCount = 2;

    // Create vertices
    bool cull = true;

    processVertex(quadOffset,                               thisMeshlet, 0, vertCount, cull);
    processVertex(quadOffset + uvec2(quadSize, 0),          thisMeshlet, 1, vertCount, cull);
    processVertex(quadOffset + uvec2(0, quadSize),          thisMeshlet, 2, vertCount, cull);
    processVertex(quadOffset + uvec2(quadSize, quadSize),   thisMeshlet, 3, vertCount, cull);


    // Add primitives
    uvec4 verts = uvec4( 0, 1, 2, 3 );

    verts += uvec4(1, 1, 1, 1) * 4 * quadID;

    gl_PrimitiveTriangleIndicesEXT[2*quadID] = uvec3(verts.y, verts.z, verts.x);
    gl_PrimitiveTriangleIndicesEXT[2*quadID + 1] = uvec3(verts.z, verts.y, verts.w);

    gl_MeshPrimitivesEXT[2*quadID].gl_CullPrimitiveEXT = cull;
    gl_MeshPrimitivesEXT[2*quadID + 1].gl_CullPrimitiveEXT = cull;

    gl_MeshPrimitivesEXT[2*quadID].gl_PrimitiveID = int(meshletID * 64 + 2*quadID);
    gl_MeshPrimitivesEXT[2*quadID + 1].gl_PrimitiveID = int(meshletID * 64 + 2*quadID + 1);



    // uint vertCount = 0;
    // uint primCount = 2;


    atomicAdd(primCounter, primCount);

    //SetMeshOutputsEXT(vertCount, primCount);

    memoryBarrierShared();
    barrier();



    if(gl_LocalInvocationID.x == 0){
        atomicAdd(renderStatistics.statistics.PrimitiveCount, primCounter);
        atomicAdd(renderStatistics.statistics.MeshShaderInvocations, meshShaderInvocations);
    }
}