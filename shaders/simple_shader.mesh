#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#extension GL_EXT_mesh_shader : enable

#include "common.h"

layout (local_size_x=CMN_MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS) in;
layout (triangles) out;

layout(max_vertices=CMN_MAX_MESH_OUTPUT_VERTICES, max_primitives=CMN_MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;


// SSBOs

layout(std430, binding = 0) buffer HeightmapData {
    float m_Heights[];
} heightmapData;

layout(std140, binding = 1) buffer MeshletDescriptions {
    MeshletDescription descriptions[];
} meshletDescriptions;



// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input

#define MAX_MESHLET_LENGTH CMN_MESHLET_LENGTH
#define MAX_MESHLET_SIZE CMN_MAX_MESH_OUTPUT_VERTICES

struct Task {
    uint    meshletID;

    uvec2   baseOffset;
    u8vec2  deltas[MAX_MESHLET_SIZE];
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    uint LODLevel;
};
taskPayloadSharedEXT Task IN;


// Indexing stuff

// gl_WorkGroupID.x runs from [0 .. parentTask.groupCountX - 1]
uint meshletID = IN.meshletID;

uint laneID = gl_LocalInvocationID.x;

// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    vec3  wNormal;
    vec3  wColor;
    flat uint meshletID;
    flat uint workgroupID;
    flat uvec2 coordinates;
    uint pointID;
} OUT[];


// Utils

uvec2 getThisPointINDeltaOffset(){
    MeshletDescription meshlet;
    meshlet.Dimensions = meshletDescriptions.descriptions[IN.meshletID].Dimensions;

    // we transform workgroupID from local to global of max meshlet
    // this is done to avoid cases where meshlet size is smaller than the globally defined max length
    uint workGroupIDGlobal = (gl_WorkGroupID.x / meshlet.Dimensions.y) * MAX_MESHLET_LENGTH + gl_WorkGroupID.x % meshlet.Dimensions.x;

    return IN.deltas[workGroupIDGlobal];
}

// get the global workgroup id
uint getPointWorkGroupID(uvec2 coordinates){
    return coordinates.y * MAX_MESHLET_LENGTH + coordinates.x;
}

float PI = 3.1415926;

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}

vec3 polarToCartesian(float lat, float lon, float height){
    float r = 50000 + height * 1 * 50000 / 6371000;
    return vec3( r * cos(lat) * sin(lon),
                 r * sin(lat),
                 r * cos(lat) * cos(lon)
                  );
}

uvec2 getPos(uvec2 pointOffset){
    uvec2 pointCoordinates = getThisPointINDeltaOffset();

    return pointCoordinates + pointOffset;
}

vec2 localPolarOffset(uvec2 offset){
    vec2 localPos = getPos(offset);

    localPos /= 1201;

    localPos *= (PI/180);

    return localPos;
}

vec3 getColorFromHeight(float height){
    vec3 Color = vec3(0.5, 0.5, 0.5);

    if(height == 0.5) Color = vec3(0.6, 0, 0.6);
    else if      (height <= 0  )   Color = vec3(0.,       0.,        1.); //blue
    else if (height < 500)   Color = vec3(0.,       height/500,    0.); //->green
    else if (height < 1000)  Color = vec3(height/500-1, 1.,        0.); //->yellow
    else if (height < 2000)  Color = vec3(1.,       2.-height/1000,0.); //->red
    else                      Color = vec3(1.,       height/2000-1 ,height/2000-1);  //->white

    return Color;
}


void main() {

    // Get point data

    MeshletDescription meshlet;
    meshlet.Offset = meshletDescriptions.descriptions[IN.meshletID].Offset;
    meshlet.Dimensions = meshletDescriptions.descriptions[IN.meshletID].Dimensions;
    meshlet.HeightmapDataOffset = meshletDescriptions.descriptions[IN.meshletID].HeightmapDataOffset;

    uvec2 pointCoordinates = getThisPointINDeltaOffset();

    // Check if points cross the heightmap border
    if (pointCoordinates.x + meshlet.Offset.x >= IN.heightmap_length ||
        pointCoordinates.y + meshlet.Offset.y >= IN.heightmap_length ){
        SetMeshOutputsEXT(0, 0);

        return;
    }

    // Check if points cross the meshlet border
    if (pointCoordinates.x >= meshlet.Dimensions.x ||
        pointCoordinates.y >= meshlet.Dimensions.y ){
        SetMeshOutputsEXT(0, 0);

        return;
    }

    uint vertCount = 6;
    uint primCount = 2;
    SetMeshOutputsEXT(vertCount, primCount);

    uint fragmentXIndex = pointCoordinates.x;
    uint fragmentYIndex = pointCoordinates.y;

    float hglen = float(IN.heightmap_length);

    uint pointID = pointCoordinates.x + pointCoordinates.y * IN.heightmap_length;



    // Calculate vertices

    uint dataOffset = meshlet.HeightmapDataOffset;

    // taken from IN.deltas already
    uvec2 deltaOffsetA = pointCoordinates;
    uvec2 deltaOffsetB = deltaOffsetA + uvec2(IN.LODLevel, 0);
    uvec2 deltaOffsetC = deltaOffsetA + uvec2(0, IN.LODLevel);
    uvec2 deltaOffsetD = deltaOffsetA + uvec2(IN.LODLevel, IN.LODLevel);

    uint offsetLinearA = uint(deltaOffsetA.x) + uint(deltaOffsetA.y) * (meshlet.Dimensions.x + 1);
    uint offsetLinearB = uint(deltaOffsetB.x) + uint(deltaOffsetB.y) * (meshlet.Dimensions.x + 1);
    uint offsetLinearC = uint(deltaOffsetC.x) + uint(deltaOffsetC.y) * (meshlet.Dimensions.x + 1);
    uint offsetLinearD = uint(deltaOffsetD.x) + uint(deltaOffsetD.y) * (meshlet.Dimensions.x + 1);




    float latitude = IN.Latitude;
    float longitude = IN.Longitude;

    float heightVertA = heightmapData.m_Heights[offsetLinearA + dataOffset];
    float heightVertB = heightmapData.m_Heights[offsetLinearB + dataOffset];
    float heightVertC = heightmapData.m_Heights[offsetLinearC + dataOffset];
    float heightVertD = heightmapData.m_Heights[offsetLinearD + dataOffset];

    vec2 polarOffset = localPolarOffset(meshlet.Offset + uvec2(0, 0));
    vec3 vertA = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x, heightmapData.m_Heights[offsetLinearA + dataOffset]);

    polarOffset = localPolarOffset(meshlet.Offset + uvec2(IN.LODLevel, 0));
    vec3 vertB = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x, heightmapData.m_Heights[offsetLinearB + dataOffset]);

    polarOffset = localPolarOffset(meshlet.Offset + uvec2(0, IN.LODLevel));
    vec3 vertC = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x, heightmapData.m_Heights[offsetLinearC + dataOffset]);

    polarOffset = localPolarOffset(meshlet.Offset + uvec2(IN.LODLevel, IN.LODLevel));
    vec3 vertD = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x, heightmapData.m_Heights[offsetLinearD + dataOffset]);

/*
    vec3 vertA = vec3( float(fragmentXIndex) / hglen, heightmapData.m_Heights[offsetLinearA + dataOffset] / 50000.0f, float(fragmentYIndex) / hglen);
    vec3 vertC = vec3( float(fragmentXIndex + 1) / hglen, heightmapData.m_Heights[offsetLinearB + dataOffset] / 50000.0f, float(fragmentYIndex) / hglen);
    vec3 vertB = vec3( float(fragmentXIndex) / hglen, heightmapData.m_Heights[offsetLinearC + dataOffset] / 50000.0f, float(fragmentYIndex + 1) / hglen);
    vec3 vertD = vec3( float(fragmentXIndex + 1) / hglen, heightmapData.m_Heights[offsetLinearD + dataOffset] / 50000.0f, float(fragmentYIndex + 1) / hglen);

    vertA *= 4;
    vertB *= 4;
    vertC *= 4;
    vertD *= 4;
*/


    vec3 norm = triangleNormal(vertB, vertA, vertC);
    /*
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }
    */
    // debug info
    OUT[0].workgroupID = gl_GlobalInvocationID.x;
    OUT[0].coordinates = uvec2(fragmentXIndex, fragmentYIndex);
    OUT[0].pointID = pointID;

    OUT[1].workgroupID = gl_GlobalInvocationID.x;
    OUT[1].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex);
    OUT[1].pointID = pointID;

    OUT[2].workgroupID = gl_GlobalInvocationID.x;
    OUT[2].coordinates = uvec2(fragmentXIndex, fragmentYIndex + 1);
    OUT[2].pointID = pointID;

    OUT[3].workgroupID = gl_WorkGroupID.x;
    OUT[3].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex + 1);
    OUT[3].pointID = pointID;

    OUT[4].workgroupID = gl_WorkGroupID.x;
    OUT[4].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex);
    OUT[4].pointID = pointID;

    OUT[5].workgroupID = gl_WorkGroupID.x;
    OUT[5].coordinates = uvec2(fragmentXIndex, fragmentYIndex + 1);
    OUT[5].pointID = pointID;


    // triag 1
    OUT[0].meshletID = meshletID;
    OUT[0].wPos = vertA;
    //OUT[0].wNormal = norm;
    OUT[0].wColor = getColorFromHeight(heightVertA);

    OUT[1].meshletID = meshletID;
    OUT[1].wPos = vertB;
    //OUT[1].wNormal = norm;
    OUT[1].wColor = getColorFromHeight(heightVertB);

    OUT[2].meshletID = meshletID;
    OUT[2].wPos = vertC;
    //OUT[2].wNormal = norm;
    OUT[2].wColor = getColorFromHeight(heightVertC);




    norm = triangleNormal(vertD, vertB, vertC);
    /*
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }
    */

    // triag 2
    OUT[3].meshletID = meshletID;
    OUT[3].wPos = vertD;
    //OUT[3].wNormal = norm;
    OUT[3].wColor = getColorFromHeight(heightVertD);

    OUT[4].meshletID = meshletID;
    OUT[4].wPos = vertB;
    //OUT[4].wNormal = norm;
    OUT[4].wColor = getColorFromHeight(heightVertB);

    OUT[5].meshletID = meshletID;
    OUT[5].wPos = vertC;
    //OUT[5].wNormal = norm;
    OUT[5].wColor = getColorFromHeight(heightVertC);


    /*
    gl_MeshVerticesEXT[0].gl_Position =  vec4(vertA, float(meshletID));
    gl_MeshVerticesEXT[1].gl_Position = vec4(vertB, float(meshletID + 1));
    gl_MeshVerticesEXT[2].gl_Position =  vec4(vertC, float(meshletID + 8));
    gl_MeshVerticesEXT[3].gl_Position =  vec4(vertD, float(meshletID + 9));
    */


    gl_MeshVerticesEXT[0].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);
    gl_MeshVerticesEXT[1].gl_Position = PushConstants.transform_matrix * vec4(vertB, 1.0);
    gl_MeshVerticesEXT[2].gl_Position = PushConstants.transform_matrix * vec4(vertC, 1.0);
    gl_MeshVerticesEXT[3].gl_Position = PushConstants.transform_matrix * vec4(vertD, 1.0);
    gl_MeshVerticesEXT[4].gl_Position = gl_MeshVerticesEXT[1].gl_Position;
    gl_MeshVerticesEXT[5].gl_Position = gl_MeshVerticesEXT[2].gl_Position;


    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(1, 0, 2);
    gl_PrimitiveTriangleIndicesEXT[1] = uvec3(3, 4, 5);


    gl_MeshPrimitivesEXT[0].gl_PrimitiveID = int(pointID) ;
    gl_MeshPrimitivesEXT[1].gl_PrimitiveID = int(pointID);

}