#version 460

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#extension GL_EXT_mesh_shader : enable

#include "common.h"

#define MAX_MESHLET_SIZE 32

layout (local_size_x=32) in;
layout (triangles) out;

layout(max_vertices=64, max_primitives=64) out;
layout(triangles) out;


layout(std430, binding = 0) buffer HeightmapData {
    float m_Heights[];
} heightmapData;

struct MeshletDescription {
    uint start;
    uint length;
};

layout(std140, binding = 1) buffer MeshletDescriptions {
    MeshletDescription descriptions[];
} meshletDescriptions;





layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;




// task shader input

struct Task {
    uint    baseID;
    uint deltaIDs[MAX_MESHLET_SIZE];
    uint    heightmap_length;
    uint    meshlet_length;


    float Longitude;
    float Latitude;
};
taskPayloadSharedEXT Task IN;


// gl_WorkGroupID.x runs from [0 .. parentTask.groupCountX - 1]
uint meshletID = IN.baseID + IN.deltaIDs[gl_WorkGroupID.x];

uint laneID = gl_LocalInvocationID.x;


// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    vec3  wNormal;
    flat uint meshletID;
    flat uint workgroupID;
    flat uint baseID;
    flat uvec2 coordinates;
    uint pointID;
} OUT[];


float PI = 3.1415926;

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}

vec3 polarToCartesian(float lat, float lon){
    return vec3( lon * sin(lat),
                 0,
                 lat
    );
}

uvec2 getPos(uvec2 pointOffset){
    uint pointID = meshletDescriptions.descriptions[IN.baseID].start + IN.deltaIDs[gl_WorkGroupID.x];

    uint fragmentXIndex = pointID % (IN.heightmap_length);
    uint fragmentYIndex = pointID / (IN.heightmap_length) ;

    return uvec2( fragmentXIndex + pointOffset.x, fragmentYIndex + pointOffset.y);
}

vec2 localPolarOffset(uvec2 pointOffset){
    uvec2 localPos = getPos(pointOffset);

    vec2 localPosF = vec2( float(localPos.x), float(localPos.y) ) / 1201;

    localPosF *= (PI/180);

    return localPosF;
}

void main() {

    uint vertCount = 6;
    uint primCount = 2;
    SetMeshOutputsEXT(vertCount, primCount);

/*
    uint pointID = meshletDescriptions.descriptions[IN.baseID].start + IN.deltaIDs[gl_WorkGroupID.x];

    float latitude = 0;
    float longitude = 0;

    vec2 polarOffset = localPolarOffset(uvec2(0, 0));
    vec3 vertA = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;

    polarOffset = localPolarOffset(uvec2(1, 0));
    vec3 vertB = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;

    polarOffset = localPolarOffset(uvec2(0, 1));
    vec3 vertC = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;

    polarOffset = localPolarOffset(uvec2(1, 1));
    vec3 vertD = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;
*/

// Old system

    uint pointID = meshletDescriptions.descriptions[IN.baseID].start + IN.deltaIDs[gl_WorkGroupID.x];

    uint fragmentXIndex = pointID % (IN.heightmap_length);
    uint fragmentYIndex = pointID / (IN.heightmap_length);


    float hglen = float(IN.heightmap_length);

    vec3 vertA = vec3( float(fragmentXIndex) / hglen, heightmapData.m_Heights[pointID] / 50000.0f, float(fragmentYIndex) / hglen);
    vec3 vertC = vec3( float(fragmentXIndex + 1) / hglen, heightmapData.m_Heights[pointID + 1] / 50000.0f, float(fragmentYIndex) / hglen);
    vec3 vertB = vec3( float(fragmentXIndex) / hglen, heightmapData.m_Heights[pointID + IN.heightmap_length] / 50000.0f, float(fragmentYIndex + 1) / hglen);
    vec3 vertD = vec3( float(fragmentXIndex + 1) / hglen, heightmapData.m_Heights[pointID + IN.heightmap_length + 1] / 50000.0f, float(fragmentYIndex + 1) / hglen);

    vertA *= 4;
    vertB *= 4;
    vertC *= 4;
    vertD *= 4;



    vec3 norm = triangleNormal(vertA, vertB, vertC);
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }

    // debug info
    OUT[0].workgroupID = gl_GlobalInvocationID.x;
    OUT[0].baseID = meshletDescriptions.descriptions[IN.baseID].start;
    OUT[0].coordinates = uvec2(fragmentXIndex, fragmentYIndex);
    OUT[0].pointID = pointID;

    OUT[1].workgroupID = gl_GlobalInvocationID.x;
    OUT[1].baseID = meshletDescriptions.descriptions[IN.baseID].start;
    OUT[1].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex);
    OUT[1].pointID = pointID;

    OUT[2].workgroupID = gl_GlobalInvocationID.x;
    OUT[2].baseID = meshletDescriptions.descriptions[IN.baseID].start;
    OUT[2].coordinates = uvec2(fragmentXIndex, fragmentYIndex + 1);
    OUT[2].pointID = pointID;

    OUT[3].workgroupID = gl_WorkGroupID.x;
    OUT[3].baseID = meshletDescriptions.descriptions[IN.baseID].start;
    OUT[3].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex + 1);
    OUT[3].pointID = pointID;

    OUT[4].workgroupID = gl_WorkGroupID.x;
    OUT[4].baseID = meshletDescriptions.descriptions[IN.baseID].start;
    OUT[4].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex);
    OUT[4].pointID = pointID;

    OUT[5].workgroupID = gl_WorkGroupID.x;
    OUT[5].baseID = meshletDescriptions.descriptions[IN.baseID].start;
    OUT[5].coordinates = uvec2(fragmentXIndex, fragmentYIndex + 1);
    OUT[5].pointID = pointID;


    // triag 1
    OUT[0].meshletID = IN.baseID;
    OUT[0].wPos = vertA;
    OUT[0].wNormal = norm;

    OUT[1].meshletID = IN.baseID;
    OUT[1].wPos = vertB;
    OUT[1].wNormal = norm;

    OUT[2].meshletID = IN.baseID;
    OUT[2].wPos = vertC;
    OUT[2].wNormal = norm;




    norm = triangleNormal(vertD, vertB, vertC);
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }

    // triag 2
    OUT[3].meshletID = IN.baseID;
    OUT[3].wPos = vertD;
    OUT[3].wNormal = norm;

    OUT[4].meshletID = IN.baseID;
    OUT[4].wPos = vertB;
    OUT[4].wNormal = norm;

    OUT[5].meshletID = IN.baseID;
    OUT[5].wPos = vertC;
    OUT[5].wNormal = norm;


    /*
    gl_MeshVerticesEXT[0].gl_Position =  vec4(vertA, float(meshletID));
    gl_MeshVerticesEXT[1].gl_Position = vec4(vertB, float(meshletID + 1));
    gl_MeshVerticesEXT[2].gl_Position =  vec4(vertC, float(meshletID + 8));
    gl_MeshVerticesEXT[3].gl_Position =  vec4(vertD, float(meshletID + 9));
    */


    gl_MeshVerticesEXT[0].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);
    gl_MeshVerticesEXT[1].gl_Position = PushConstants.transform_matrix * vec4(vertB, 1.0);
    gl_MeshVerticesEXT[2].gl_Position = PushConstants.transform_matrix * vec4(vertC, 1.0);
    gl_MeshVerticesEXT[3].gl_Position = PushConstants.transform_matrix * vec4(vertD, 1.0);
    gl_MeshVerticesEXT[4].gl_Position = gl_MeshVerticesEXT[1].gl_Position;
    gl_MeshVerticesEXT[5].gl_Position = gl_MeshVerticesEXT[2].gl_Position;


    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    gl_PrimitiveTriangleIndicesEXT[1] = uvec3(3, 4, 5);


    gl_MeshPrimitivesEXT[0].gl_PrimitiveID = int(pointID) ;
    gl_MeshPrimitivesEXT[1].gl_PrimitiveID = int(pointID);

}