#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_mesh_shader : enable

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]

#include "common.h"

layout (local_size_x=MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS) in;
layout (triangles) out;

layout(max_vertices=MAX_MESH_OUTPUT_VERTICES, max_primitives=MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;

// SSBOs

layout(std430, binding = 0) buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

layout(std140, binding = 1) buffer MeshletDescriptions {
    MeshletDescription descriptions[];
} meshletDescriptions;



// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input

struct Task {
    uint   baseMeshletIDOffset;
    uint   meshletIDLocalOffset[MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS];
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    uint LODLevel;
};
taskPayloadSharedEXT Task IN;


// Indexing stuff

uint laneID = gl_LocalInvocationID.x;

// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    vec3  wNormal;
    vec3  wColor;
    float   wHeight;
    flat  uint meshletID;
} OUT[];


// Utils


float PI = 3.1415926;

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}

vec3 polarToCartesian(float lat, float lon, float height){
    float r = 50000 + height * 1 * 50000 / 6371000;
    return vec3( r * cos(lat) * sin(lon),
                 r * sin(lat),
                 r * cos(lat) * cos(lon)
                  );
}

vec2 localPolarOffset(uvec2 offset){
    return (offset * PI ) / (180 * 1201);
}

void processVertex(uvec2 vertexOffset, MeshletDescription meshlet, inout uint vertexCount){
    if (meshlet.Dimensions.x <= vertexOffset.x ||
        meshlet.Dimensions.y <= vertexOffset.y)
        return;

    uint heightmapIndex = meshlet.HeightmapDataOffset +  vertexOffset.y * meshlet.Dimensions.x + vertexOffset.x;

    vec2 polarOffset = localPolarOffset(meshlet.Offset + vertexOffset + uvec2(0, 0));
    vec3 vertA = polarToCartesian(IN.Latitude + polarOffset.y, IN.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    // Interpolants
    OUT[vertexCount].meshletID = gl_WorkGroupID.x;
    OUT[vertexCount].wPos = vertA;
    int height = int(heightmapData.m_Heights[heightmapIndex]);
    OUT[vertexCount].wHeight = float(height);


    gl_MeshVerticesEXT[vertexCount].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);

    vertexCount++;
}


void createQuad(uvec2 quadOffset, MeshletDescription meshlet, inout uint primitiveCount){

    if (meshlet.Dimensions.x - IN.LODLevel <= quadOffset.x ||
        meshlet.Dimensions.y - IN.LODLevel <= quadOffset.y)
        return;


    uint vertAIndex =  quadOffset.x                 + quadOffset.y                  * meshlet.Dimensions.x;
    uint vertBIndex = (quadOffset.x + IN.LODLevel)  + quadOffset.y                  * meshlet.Dimensions.x;
    uint vertCIndex =  quadOffset.x                 + (quadOffset.y + IN.LODLevel)  * meshlet.Dimensions.x;
    uint vertDIndex = (quadOffset.x + IN.LODLevel)  + (quadOffset.y + IN.LODLevel)  * meshlet.Dimensions.x;

    gl_PrimitiveTriangleIndicesEXT[primitiveCount + 0] = uvec3(vertBIndex, vertAIndex, vertCIndex);
    gl_PrimitiveTriangleIndicesEXT[primitiveCount + 1] = uvec3(vertCIndex, vertDIndex, vertBIndex);


    gl_MeshPrimitivesEXT[primitiveCount + 0].gl_PrimitiveID = int(gl_WorkGroupID.x);
    gl_MeshPrimitivesEXT[primitiveCount + 1].gl_PrimitiveID = int(gl_WorkGroupID.x);

    primitiveCount += 2;
}

void getMeshlet(inout MeshletDescription meshletDescription){
    meshletDescription.Offset = meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]].Offset;
    meshletDescription.Dimensions = meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]].Dimensions;
    meshletDescription.HeightmapDataOffset = meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]].HeightmapDataOffset;
}

void main() {

    // Get meshlet data

    MeshletDescription thisMeshlet;

    getMeshlet(thisMeshlet);

    uint vertCount = 0;
    uint primCount = 0;

    // generate vertices
    for(uint quadID = 0; quadID < (MESHLET_LENGTH)*(MESHLET_LENGTH); quadID++){

        uvec2 coord = uvec2(quadID % (MESHLET_LENGTH), quadID / (MESHLET_LENGTH));
        processVertex(coord, thisMeshlet, vertCount);
        createQuad(coord, thisMeshlet, primCount);
    }

    SetMeshOutputsEXT(vertCount, primCount);
}