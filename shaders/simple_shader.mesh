#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes: require

#extension GL_EXT_mesh_shader : enable

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#extension GL_EXT_shader_atomic_int64 : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]

#include "common.h"

layout (local_size_x=MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS) in;
layout (triangles) out;

layout(max_vertices=MAX_MESH_OUTPUT_VERTICES, max_primitives=MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;

// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif


struct RenderStatistics
{
    uint64_t PrimitiveCount;
};

layout(std430, binding = 2) writeonly buffer RenderStats {
    RenderStatistics statistics;
} renderStatistics;

shared uint primCounter;

// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input

struct Task {
    uint   baseMeshletIDOffset;
    uint   meshletIDLocalOffset[MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS];
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    uint LODLevel;
    vec3  observatorPosition;
};
taskPayloadSharedEXT Task IN;

uint LOD_LEVEL = IN.LODLevel;
float dist;

// Indexing stuff

uint laneID = gl_LocalInvocationID.x;

// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    float   wHeight;
    flat  uint meshletID;
    flat float DistFromObservator;
} OUT[];


// Utils


float PI = 3.1415926;

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}

vec3 polarToCartesian(float lat, float lon, float height){
    float r = 50000 + height * 1 * 50000 / 6371000;
    return vec3( r * cos(lat) * sin(lon),
                 r * sin(lat),
                 r * cos(lat) * cos(lon)
                  );
}

vec2 localPolarOffset(uvec2 offset){
    offset.y = 1200 - offset.y;
    vec2 res = (offset * PI ) / (180 * 1200);
    return res;
}

void processVertex(uvec2 vertexOffset, MeshletDescription meshlet, inout uint vertexCount){

    uint scaledXDimension = uint( ceil( float(meshlet.Dimensions.x) / float(LOD_LEVEL)));
    uint vertIndex =  vertexOffset.x + vertexOffset.y * scaledXDimension;

    // we perform calculations as if there was no LOD
    vertexOffset *= LOD_LEVEL;

/*
    if (meshlet.Dimensions.x <= vertexOffset.x ||
        meshlet.Dimensions.y <= vertexOffset.y)
        return;
*/

    uint heightmapIndex = meshlet.HeightmapDataOffset +  vertexOffset.y * meshlet.Dimensions.x + vertexOffset.x;

    vec2 polarOffset = localPolarOffset(meshlet.Offset + vertexOffset + uvec2(0, 0));
    vec3 vertA = polarToCartesian(IN.Latitude + polarOffset.y, IN.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));



    // Interpolants
    OUT[vertIndex].meshletID = gl_WorkGroupID.x;
    OUT[vertIndex].wPos = vertA;
    int height = int(heightmapData.m_Heights[heightmapIndex]);
    OUT[vertIndex].wHeight = float(height);
    OUT[vertIndex].DistFromObservator = dist;
    OUT[vertIndex].meshletID = gl_WorkGroupID.x;


    gl_MeshVerticesEXT[vertIndex].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);
    //gl_MeshVerticesEXT[vertexCount].gl_Position = vec4(0, 0, 0, 0);


    vertexCount++;
}

vec3 generalMeshletPosition(MeshletDescription meshlet) {
    uvec2 vertexOffset = uvec2(0, 0);

    uint heightmapIndex = meshlet.HeightmapDataOffset +  vertexOffset.y * meshlet.Dimensions.x + vertexOffset.x;

    vec2 polarOffset = localPolarOffset(meshlet.Offset + vertexOffset + uvec2(0, 0));
    vec3 vertA = polarToCartesian(IN.Latitude + polarOffset.y, IN.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    return vertA;
}

float observerHorizonDistance(){
    float height = length(IN.observatorPosition) - 50000;

    return sqrt(2 * 50000 * height + height*height);
}

void createQuad(uvec2 quadOffset, MeshletDescription meshlet, inout uint primitiveCount){

    uvec2 scaledDimensions = meshlet.Dimensions;
    //scaledDimensions /= LOD_LEVEL;

    scaledDimensions.x = uint( ceil( float(scaledDimensions.x) / float(LOD_LEVEL)));
    scaledDimensions.y = uint( ceil( float(scaledDimensions.y) / float(LOD_LEVEL)));


    if (scaledDimensions.x <= quadOffset.x + 1 ||
        scaledDimensions.y <= quadOffset.y + 1)
        return;


    uint vertAIndex =  quadOffset.x       + quadOffset.y        * scaledDimensions.x;
    uint vertBIndex = (quadOffset.x + 1)  + quadOffset.y        * scaledDimensions.x;
    uint vertCIndex =  quadOffset.x       + (quadOffset.y + 1)  * scaledDimensions.x;
    uint vertDIndex = (quadOffset.x + 1)  + (quadOffset.y + 1)  * scaledDimensions.x;


    gl_PrimitiveTriangleIndicesEXT[primitiveCount + 0] = uvec3(vertBIndex, vertCIndex, vertAIndex);
    gl_PrimitiveTriangleIndicesEXT[primitiveCount + 1] = uvec3(vertCIndex, vertBIndex, vertDIndex);

    gl_MeshPrimitivesEXT[primitiveCount + 0].gl_PrimitiveID = int(gl_WorkGroupID.x);
    gl_MeshPrimitivesEXT[primitiveCount + 1].gl_PrimitiveID = int(gl_WorkGroupID.x);

    primitiveCount += 2;
}

void main() {

/*
    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    gl_MeshVerticesEXT[0].gl_Position = vec4(0, 0, 0, 0);
    gl_MeshVerticesEXT[1].gl_Position = vec4(0, 1, 0, 0);
    gl_MeshVerticesEXT[2].gl_Position = vec4(0, 0, 1, 0);

    MeshletDescription thisMeshlet;

    decodeMeshlet(meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]], thisMeshlet);

    OUT[0].MeshletOffset = thisMeshlet.Offset;
    OUT[0].MeshletDimensions = thisMeshlet.Dimensions;


    SetMeshOutputsEXT(3, 1);

    return;
*/

    primCounter = 0;

    memoryBarrierShared();
    barrier();


    // Get meshlet data

    MeshletDescription thisMeshlet;

#if ENCODED_MESHLETS
    decodeMeshlet(meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]], thisMeshlet);
#else
    thisMeshlet = meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]];
#endif


    // Choose LOD level
    vec3 meshletPos = generalMeshletPosition(thisMeshlet);
    dist = length(meshletPos - IN.observatorPosition);


    /*
    if(dist > 1000)
        LOD_LEVEL = 8;
    else if(dist > 500)
        LOD_LEVEL = 4;
    else if(dist > 250)
        LOD_LEVEL = 2;
    */

    LOD_LEVEL = 1 << int(clamp(dist, 0, 800) / 250);
    LOD_LEVEL = clamp(LOD_LEVEL, 1, 8);

/*
    // TODO: this doesn't account for curvature of the earth so there's some overhead
    if(dist > 1.1f * observerHorizonDistance()){
        SetMeshOutputsEXT(0, 0);
        return;
    }
*/
   // LOD_LEVEL = 1;

    uint vertCount = 0;
    uint primCount = 0;

    uint scaledLength = uint(ceil( float(MESHLET_LENGTH) / float(LOD_LEVEL)));

    for(uint y = 0; y < scaledLength; y++ ){
        for(uint x = 0; x < scaledLength; x++ ){
            uvec2 coord = uvec2(x, y);

            processVertex(coord, thisMeshlet, vertCount);
            createQuad(coord, thisMeshlet, primCount);
        }
    }

/*
    for(uint y = scaledLength - 1; y < scaledLength; y++ ){
        for(uint x = scaledLength - 1; x < scaledLength; x++ ){
            uvec2 coord = uvec2(x, y);

            processVertex(coord, thisMeshlet, vertCount);
        }
    }
*/
    atomicAdd(primCounter, primCount);

    SetMeshOutputsEXT(vertCount, primCount);

    memoryBarrierShared();
    barrier();

    if(gl_GlobalInvocationID.x == 0)
        atomicAdd(renderStatistics.statistics.PrimitiveCount, primCounter);
}