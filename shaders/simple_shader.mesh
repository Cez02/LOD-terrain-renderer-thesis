#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes: require

#extension GL_EXT_mesh_shader : enable

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#extension GL_EXT_shader_atomic_int64 : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]

#include "common.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(max_vertices=MAX_MESH_OUTPUT_VERTICES, max_primitives=MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;

// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif


struct RenderStatistics
{
    uint64_t PrimitiveCount;
    uint64_t TaskShaderInvocations;
    uint64_t MeshShaderInvocations;

};

layout(std430, binding = 2) writeonly buffer RenderStats {
    RenderStatistics statistics;
} renderStatistics;

shared uint primCounter;
shared uint meshShaderInvocations;

// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input

struct Task {
    u8vec4 quadDescriptions[2049 * MESHLETS_PER_TASK_INVOCATION];


    uint   baseMeshletID;
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    vec3 observatorPosition;

    uint quadCount;

    uint invocationID;
    uint globalID;
    uint workgroupID;
};

taskPayloadSharedEXT Task IN;

// Indexing stuff

uint localQuadID = gl_LocalInvocationID.x;
uint quadID = gl_WorkGroupSize.x * gl_WorkGroupID.x + localQuadID;
uint meshletID = IN.baseMeshletID + uint(IN.quadDescriptions[quadID].x);



// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    float   wHeight;
    flat  uint meshletID;
    flat uint laneID;
    flat float DistFromObservator;
} OUT[];


// Utils

void decodeQuadDescription(out uint8_t meshletOffset, out uint8_t quadOffset, out uint8_t quadStride){
    meshletOffset = IN.quadDescriptions[quadID].x;
    quadOffset = IN.quadDescriptions[quadID].y;
    quadStride = IN.quadDescriptions[quadID].z;
}


uvec2 scaledDimensions;


void processVertex(uvec2 vertexOffset, MeshletDescription meshlet, int vertexIndexOffset, inout uint vertexCount, inout bool cull){

    uint vertIndex = vertexIndexOffset + 4 * localQuadID;

    uint heightmapIndex = meshlet.HeightmapDataOffset + vertexOffset.x + meshlet.Dimensions.x * vertexOffset.y;
    float height = float(int(heightmapData.m_Heights[heightmapIndex]));

    vec3 vertA = vertexToPolarToCartesian(meshlet.Offset + vertexOffset, IN.Latitude, IN.Longitude, height);

    // Interpolants
    OUT[vertIndex].wPos = vertA;
    OUT[vertIndex].wHeight = height;
    OUT[vertIndex].DistFromObservator = 0;
    OUT[vertIndex].meshletID = meshletID;
    OUT[vertIndex].laneID = 0;


    gl_MeshVerticesEXT[vertIndex].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);

    float observerHorizonDistance = observerHorizonDistance(IN.observatorPosition);
    cull = cull && (observerHorizonDistance < length(vertA - IN.observatorPosition));

    vertexCount += 1;

}


void main() {

/*
    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);

    gl_MeshVerticesEXT[0].gl_Position = vec4(0, 1, 0, 1);
    gl_MeshVerticesEXT[1].gl_Position = vec4(1, 1, 0, 1);
    gl_MeshVerticesEXT[2].gl_Position = vec4(0, 1, 1, 1);

    SetMeshOutputsEXT(3, 1);

    return;
    */


    primCounter = 0;
    meshShaderInvocations = 0;

    bool skip = quadID > IN.quadCount;


    if(skip){
        return;
    }


    quadID = min(quadID, IN.quadCount - 1);

    uint workGroupQuadCount = min(32, IN.quadCount - gl_WorkGroupID.x * 32);

    SetMeshOutputsEXT(4 * workGroupQuadCount, 2 * workGroupQuadCount);

    memoryBarrierShared();
    barrier();

    atomicAdd(meshShaderInvocations, 1);



    // Grab quad data

    MeshletDescription thisMeshlet = meshletDescriptions.descriptions[meshletID];

    uint8_t meshletOffset, quadOffset, quadStride;
    decodeQuadDescription(meshletOffset, quadOffset, quadStride);


    uvec2 quadCoords = uvec2(quadOffset % thisMeshlet.Dimensions.x, quadOffset / thisMeshlet.Dimensions.x);


    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);

    gl_MeshVerticesEXT[0].gl_Position = vec4(meshletOffset, quadOffset, quadStride, 1);
    gl_MeshVerticesEXT[1].gl_Position = vec4(1, 1, 0, 1);
    gl_MeshVerticesEXT[2].gl_Position = vec4(0, 1, 1, 1);



    uint vertCount = 0;
    uint primCount = 2;


    // Create vertices
    bool cull = true;

    processVertex(quadCoords,                               thisMeshlet, 0, vertCount, cull);
    processVertex(quadCoords + uvec2(quadStride, 0),          thisMeshlet, 1, vertCount, cull);
    processVertex(quadCoords + uvec2(0, quadStride),          thisMeshlet, 2, vertCount, cull);
    processVertex(quadCoords + uvec2(quadStride, quadStride),   thisMeshlet, 3, vertCount, cull);


    // Add primitives
    uvec4 verts = uvec4( 0, 1, 2, 3 );

    verts += uvec4(1, 1, 1, 1) * 4 * localQuadID;

    gl_PrimitiveTriangleIndicesEXT[2*localQuadID] = uvec3(verts.y, verts.z, verts.x);
    gl_PrimitiveTriangleIndicesEXT[2*localQuadID + 1] = uvec3(verts.z, verts.y, verts.w);

    gl_MeshPrimitivesEXT[2*localQuadID].gl_CullPrimitiveEXT = cull;
    gl_MeshPrimitivesEXT[2*localQuadID + 1].gl_CullPrimitiveEXT = cull;

    gl_MeshPrimitivesEXT[2*localQuadID].gl_PrimitiveID = int(meshletID * 64 + 2*localQuadID);
    gl_MeshPrimitivesEXT[2*localQuadID + 1].gl_PrimitiveID = int(meshletID * 64 + 2*localQuadID + 1);



    // uint vertCount = 0;
    // uint primCount = 2;


    atomicAdd(primCounter, primCount);

    //SetMeshOutputsEXT(vertCount, primCount);

    memoryBarrierShared();
    barrier();



    if(gl_LocalInvocationID.x == 0){
        atomicAdd(renderStatistics.statistics.PrimitiveCount, primCounter);
        atomicAdd(renderStatistics.statistics.MeshShaderInvocations, meshShaderInvocations);
    }
}