#version 460

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_mesh_shader : enable

layout (local_size_x=49) in;
layout (triangles) out;

layout(max_vertices=64, max_primitives=64) out;
layout(triangles) out;


layout(std430, binding = 0) buffer HeightmapData {
    float m_Heights[];
} heightmapData;


layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// task shader input

struct Task {
    uint    baseID;
    uint deltaIDs[128];
};
taskPayloadSharedEXT Task IN;


// gl_WorkGroupID.x runs from [0 .. parentTask.groupCountX - 1]
uint meshletID = IN.baseID + IN.deltaIDs[gl_WorkGroupID.x];

uint laneID = gl_LocalInvocationID.x;


// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    vec3  wNormal;
    flat uint meshletID;
} OUT[];


/*
Nx = Ay * Bz - Az * By
Ny = Az * Bx - Ax * Bz
Nz = Ax * By - Ay * Bx
*/

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}


void main() {

    uint vertCount = 6;
    uint primCount = 2;
    SetMeshOutputsEXT(vertCount, primCount);

    uint fragmentXIndex = meshletID % 7;
    uint fragmentYIndex = meshletID / 7;

    uint startingHeight = fragmentXIndex + fragmentYIndex * 8;

    vec3 vertA = vec3( float(fragmentXIndex) / 8.0, heightmapData.m_Heights[startingHeight], float(fragmentYIndex) / 8.0);
    vec3 vertB = vec3( float(fragmentXIndex + 1) / 8.0, heightmapData.m_Heights[startingHeight + 1], float(fragmentYIndex) / 8.0);
    vec3 vertC = vec3( float(fragmentXIndex) / 8.0, heightmapData.m_Heights[startingHeight + 8], float(fragmentYIndex + 1) / 8.0);
    vec3 vertD = vec3( float(fragmentXIndex + 1) / 8.0, heightmapData.m_Heights[startingHeight + 9], float(fragmentYIndex + 1) / 8.0);


    vec3 norm = triangleNormal(vertA, vertB, vertC);
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }

    // triag 1
    OUT[0].meshletID = meshletID;
    OUT[0].wPos = vertA;
    OUT[0].wNormal = norm;

    OUT[1].meshletID = meshletID;
    OUT[1].wPos = vertB;
    OUT[1].wNormal = norm;

    OUT[2].meshletID = meshletID;
    OUT[2].wPos = vertC;
    OUT[2].wNormal = norm;




    norm = triangleNormal(vertD, vertB, vertC);
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }

    // triag 2
    OUT[3].meshletID = meshletID;
    OUT[3].wPos = vertD;
    OUT[3].wNormal = norm;

    OUT[4].meshletID = meshletID;
    OUT[4].wPos = vertB;
    OUT[4].wNormal = norm;

    OUT[5].meshletID = meshletID;
    OUT[5].wPos = vertC;
    OUT[5].wNormal = norm;

    /*
    gl_MeshVerticesEXT[0].gl_Position =  vec4(vertA, float(meshletID));
    gl_MeshVerticesEXT[1].gl_Position = vec4(vertB, float(meshletID + 1));
    gl_MeshVerticesEXT[2].gl_Position =  vec4(vertC, float(meshletID + 8));
    gl_MeshVerticesEXT[3].gl_Position =  vec4(vertD, float(meshletID + 9));
    */


    gl_MeshVerticesEXT[0].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);
    gl_MeshVerticesEXT[1].gl_Position = PushConstants.transform_matrix * vec4(vertB, 1.0);
    gl_MeshVerticesEXT[2].gl_Position = PushConstants.transform_matrix * vec4(vertC, 1.0);
    gl_MeshVerticesEXT[3].gl_Position = PushConstants.transform_matrix * vec4(vertD, 1.0);
    gl_MeshVerticesEXT[4].gl_Position = gl_MeshVerticesEXT[1].gl_Position;
    gl_MeshVerticesEXT[5].gl_Position = gl_MeshVerticesEXT[2].gl_Position;


    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    gl_PrimitiveTriangleIndicesEXT[1] = uvec3(3, 4, 5);


    gl_MeshPrimitivesEXT[0].gl_PrimitiveID = int(2*meshletID) ;
    gl_MeshPrimitivesEXT[1].gl_PrimitiveID = int(2*meshletID + 1);


}