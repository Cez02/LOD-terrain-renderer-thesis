#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_control_flow_attributes: require

#extension GL_EXT_mesh_shader : enable

#extension GL_EXT_shader_16bit_storage : require

#extension GL_EXT_shader_explicit_arithmetic_types_int8  : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#extension GL_EXT_shader_atomic_int64 : require

#extension GL_EXT_control_flow_attributes: require
#define UNROLL_LOOP [[unroll]]

#include "common.h"

layout (local_size_x=MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS) in;
layout (triangles) out;

layout(max_vertices=MAX_MESH_OUTPUT_VERTICES, max_primitives=MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;

// SSBOs

layout(std430, binding = 0) readonly buffer HeightmapData {
    int16_t m_Heights[];
} heightmapData;

#ifdef ENCODED_MESHLETS

    layout(std430, binding = 1) readonly buffer MeshletDescriptions {
        EncodedMeshletDescription descriptions[];
    } meshletDescriptions;

#else

    layout(std140, binding = 1) readonly buffer MeshletDescriptions {
        MeshletDescription descriptions[];
    } meshletDescriptions;

#endif


struct RenderStatistics
{
    uint64_t PrimitiveCount;
    uint64_t TaskShaderInvocations;
    uint64_t MeshShaderInvocations;

};

layout(std430, binding = 2) writeonly buffer RenderStats {
    RenderStatistics statistics;
} renderStatistics;

shared uint primCounter;
shared uint meshShaderInvocations;

// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input

struct Task {
    uint   baseMeshletIDOffset;
    uint   meshletIDLocalOffset[MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS];
    uint    heightmap_length;

    float Longitude;
    float Latitude;

    uint LODLevel;
    vec3  observatorPosition;
};
taskPayloadSharedEXT Task IN;

uint LOD_LEVEL = IN.LODLevel;
float dist;

// Indexing stuff

uint laneID;


// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    float   wHeight;
    flat  uint meshletID;
    flat uint laneID;
    flat float DistFromObservator;
} OUT[];


// Utils


uvec2 scaledDimensions;

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}

void processVertex(uvec2 vertexOffset, MeshletDescription meshlet, inout uint vertexCount){

    int keepVertex = int( scaledDimensions.x > vertexOffset.x && scaledDimensions.y > vertexOffset.y );

    uint vertIndex =  vertexOffset.x + vertexOffset.y * scaledDimensions.x;

    // we perform calculations as if there was no LOD
    vertexOffset *= LOD_LEVEL;

    uint heightmapIndex = meshlet.HeightmapDataOffset +  vertexOffset.y * meshlet.Dimensions.x + vertexOffset.x;

    vec2 polarOffset = localPolarOffset(meshlet.Offset + vertexOffset + uvec2(0, 0));
    vec3 vertA = polarToCartesian(IN.Latitude + polarOffset.y, IN.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    // Interpolants
    OUT[vertIndex].wPos = vertA;
    int height = int(heightmapData.m_Heights[heightmapIndex]);
    OUT[vertIndex].wHeight = float(height);
    OUT[vertIndex].DistFromObservator = dist;
    OUT[vertIndex].meshletID = IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x];
    OUT[vertIndex].laneID = laneID;


    gl_MeshVerticesEXT[vertIndex].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);
    //gl_MeshVerticesEXT[vertexCount].gl_Position = vec4(0, 0, 0, 0);

    vertexCount += keepVertex;
}

vec3 generalMeshletPosition(MeshletDescription meshlet) {
    uint heightmapIndex = meshlet.HeightmapDataOffset;

    vec2 polarOffset = localPolarOffset(meshlet.Offset);
    vec3 vertA = polarToCartesian(IN.Latitude + polarOffset.y, IN.Longitude + polarOffset.x, float(int(heightmapData.m_Heights[heightmapIndex])));

    return vertA;
}

void createQuad(uvec2 quadOffset, MeshletDescription meshlet, inout uint primitiveCount){

    int keepQuad = int( scaledDimensions.x > quadOffset.x + 1 && scaledDimensions.y > quadOffset.y + 1 );

    uint vertAIndex =  quadOffset.x       + quadOffset.y        * scaledDimensions.x;
    uint vertBIndex = (quadOffset.x + 1)  + quadOffset.y        * scaledDimensions.x;
    uint vertCIndex =  quadOffset.x       + (quadOffset.y + 1)  * scaledDimensions.x;
    uint vertDIndex = (quadOffset.x + 1)  + (quadOffset.y + 1)  * scaledDimensions.x;

    gl_PrimitiveTriangleIndicesEXT[primitiveCount + 0] = uvec3(vertBIndex, vertCIndex, vertAIndex);
    gl_PrimitiveTriangleIndicesEXT[primitiveCount + 1] = uvec3(vertCIndex, vertBIndex, vertDIndex);

    gl_MeshPrimitivesEXT[primitiveCount + 0].gl_PrimitiveID = int(primitiveCount);
    gl_MeshPrimitivesEXT[primitiveCount + 1].gl_PrimitiveID = int(primitiveCount + 1);

    primitiveCount += 2 * keepQuad;

}

void main() {

/*
    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    gl_MeshVerticesEXT[0].gl_Position = vec4(0, 0, 0, 0);
    gl_MeshVerticesEXT[1].gl_Position = vec4(0, 1, 0, 0);
    gl_MeshVerticesEXT[2].gl_Position = vec4(0, 0, 1, 0);

    MeshletDescription thisMeshlet;

    decodeMeshlet(meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]], thisMeshlet);

    OUT[0].MeshletOffset = thisMeshlet.Offset;
    OUT[0].MeshletDimensions = thisMeshlet.Dimensions;


    SetMeshOutputsEXT(3, 1);

    return;
*/

    primCounter = 0;
    meshShaderInvocations = 0;

    memoryBarrierShared();
    barrier();

    atomicAdd(meshShaderInvocations, 1);

    laneID = gl_LocalInvocationIndex;

    // Get meshlet data

    MeshletDescription thisMeshlet;

#if ENCODED_MESHLETS
    decodeMeshlet(meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]], thisMeshlet);
#else
    thisMeshlet = meshletDescriptions.descriptions[IN.baseMeshletIDOffset + IN.meshletIDLocalOffset[gl_WorkGroupID.x]];
#endif


    // Choose LOD level
    vec3 meshletPos = generalMeshletPosition(thisMeshlet);
    dist = length(meshletPos - IN.observatorPosition);


    /*
    if(dist > 1000)
        LOD_LEVEL = 8;
    else if(dist > 500)
        LOD_LEVEL = 4;
    else if(dist > 250)
        LOD_LEVEL = 2;
    */

    LOD_LEVEL = 1 << int(clamp(dist, 0, 800) / 250);
    LOD_LEVEL = clamp(LOD_LEVEL, 1, 8);
    //LOD_LEVEL = 1;


    // setup in-meshlet common variables

    scaledDimensions = thisMeshlet.Dimensions;

    scaledDimensions.x = uint( ceil( float(scaledDimensions.x) / float(LOD_LEVEL)));
    scaledDimensions.y = uint( ceil( float(scaledDimensions.y) / float(LOD_LEVEL)));





    uint vertCount = 0;
    uint primCount = 0;

    uint scaledLength = uint(ceil( float(MESHLET_LENGTH) / float(LOD_LEVEL)));


    UNROLL_LOOP
    for(uint y = 0; y < scaledLength; y++ ){
        UNROLL_LOOP
        for(uint x = 0; x < scaledLength; x++ ){
            uvec2 coord = uvec2(x, y);

            processVertex(coord, thisMeshlet, vertCount);
            createQuad(coord, thisMeshlet, primCount);
        }
    }




    atomicAdd(primCounter, primCount);

    SetMeshOutputsEXT(vertCount, primCount);

    memoryBarrierShared();
    barrier();

    if(gl_GlobalInvocationID.x == 0){
        atomicAdd(renderStatistics.statistics.PrimitiveCount, primCounter);
        atomicAdd(renderStatistics.statistics.MeshShaderInvocations, meshShaderInvocations);
    }
}