#version 460

// Setup

#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require

#extension GL_EXT_mesh_shader : enable

#include "common.h"

layout (local_size_x=CMN_MAX_PREFERRED_MESH_WORK_GROUP_INVOCATIONS) in;
layout (triangles) out;

layout(max_vertices=CMN_MAX_MESH_OUTPUT_VERTICES, max_primitives=CMN_MAX_MESH_OUTPUT_PRIMITIVES) out;
layout(triangles) out;


// SSBOs

layout(std430, binding = 0) buffer HeightmapData {
    float m_Heights[];
} heightmapData;

layout(std140, binding = 1) buffer MeshletDescriptions {
    MeshletDescription descriptions[];
} meshletDescriptions;



// Push constants

layout( push_constant ) uniform constants
{
	mat4 transform_matrix;
} PushConstants;


// Task shader input

#define MAX_MESHLET_SIZE CMN_MAX_MESH_OUTPUT_VERTICES

struct Task {
    uint    meshletID;

    uvec2   baseOffset;
    u8vec2  deltas[MAX_MESHLET_SIZE];
    uint    heightmap_length;

    float Longitude;
    float Latitude;
};
taskPayloadSharedEXT Task IN;


// Indexing stuff

// gl_WorkGroupID.x runs from [0 .. parentTask.groupCountX - 1]
uint meshletID = IN.meshletID;

uint laneID = gl_LocalInvocationID.x;


// Output

layout(location=0) out Interpolants {
    vec3  wPos;
    vec3  wNormal;
    flat uint meshletID;
    flat uint workgroupID;
    flat uvec2 coordinates;
    uint pointID;
} OUT[];


float PI = 3.1415926;

vec3 triangleNormal(vec3 a, vec3 b, vec3 c){

    vec3 A = b - a;
    vec3 B = c - a;

    return normalize(vec3(
        A.y * B.z - A.z * B.y,
        A.z * B.x - A.x * B.z,
        A.x * B.y - A.y * B.x
    ));

}

vec3 polarToCartesian(float lat, float lon){
    return vec3( lon * sin(lat),
                 0,
                 lat
    );
}

uvec2 getPos(uvec2 pointOffset){
    uvec2 pointCoordinates = meshletDescriptions.descriptions[IN.meshletID].Offset + IN.deltas[gl_WorkGroupID.x];

    uint fragmentXIndex = pointCoordinates.x;
    uint fragmentYIndex = pointCoordinates.y;

    return uvec2( fragmentXIndex + pointOffset.x, fragmentYIndex + pointOffset.y);
}

vec2 localPolarOffset(uvec2 pointOffset){
    uvec2 localPos = getPos(pointOffset);

    vec2 localPosF = vec2( float(localPos.x), float(localPos.y) ) / 1201;

    localPosF *= (PI/180);

    return localPosF;
}

void main() {

/*
    uint pointID = meshletDescriptions.descriptions[IN.baseID].start + IN.deltaIDs[gl_WorkGroupID.x];

    float latitude = 0;
    float longitude = 0;

    vec2 polarOffset = localPolarOffset(uvec2(0, 0));
    vec3 vertA = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;

    polarOffset = localPolarOffset(uvec2(1, 0));
    vec3 vertB = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;

    polarOffset = localPolarOffset(uvec2(0, 1));
    vec3 vertC = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;

    polarOffset = localPolarOffset(uvec2(1, 1));
    vec3 vertD = polarToCartesian(latitude + polarOffset.y, longitude + polarOffset.x) * 10000;
*/

// Old system

    MeshletDescription meshlet;
    meshlet.Offset = meshletDescriptions.descriptions[IN.meshletID].Offset;
    meshlet.Dimensions = meshletDescriptions.descriptions[IN.meshletID].Dimensions;
    meshlet.HeightmapDataOffset = meshletDescriptions.descriptions[IN.meshletID].HeightmapDataOffset;

    uvec2 pointCoordinates = meshlet.Offset + IN.deltas[gl_WorkGroupID.x];

    if (pointCoordinates.x + meshlet.Dimensions.x >= IN.heightmap_length ||
        pointCoordinates.y + meshlet.Dimensions.y >= IN.heightmap_length ){
        SetMeshOutputsEXT(0, 0);

        return;
    }

    uint vertCount = 6;
    uint primCount = 2;
    SetMeshOutputsEXT(vertCount, primCount);

    uint fragmentXIndex = pointCoordinates.x;
    uint fragmentYIndex = pointCoordinates.y;

    float hglen = float(IN.heightmap_length);

    uint pointID = pointCoordinates.x + pointCoordinates.y * IN.heightmap_length;


    uint dataOffset = meshlet.HeightmapDataOffset;
    u8vec2 pointDelta = IN.deltas[gl_WorkGroupID.x];

    uint offsetLinearA = uint(pointDelta.x) + uint(pointDelta.y) * (meshlet.Dimensions.x + 1);
    uint offsetLinearB = uint(pointDelta.x + 1) + uint(pointDelta.y) * (meshlet.Dimensions.x + 1);
    uint offsetLinearC = uint(pointDelta.x) + uint(pointDelta.y + 1) * (meshlet.Dimensions.x + 1);
    uint offsetLinearD = uint(pointDelta.x + 1) + uint(pointDelta.y + 1) * (meshlet.Dimensions.x + 1);

    vec3 vertA = vec3( float(fragmentXIndex) / hglen, heightmapData.m_Heights[offsetLinearA + dataOffset] / 50000.0f, float(fragmentYIndex) / hglen);
    vec3 vertC = vec3( float(fragmentXIndex + 1) / hglen, heightmapData.m_Heights[offsetLinearB + dataOffset] / 50000.0f, float(fragmentYIndex) / hglen);
    vec3 vertB = vec3( float(fragmentXIndex) / hglen, heightmapData.m_Heights[offsetLinearC + dataOffset] / 50000.0f, float(fragmentYIndex + 1) / hglen);
    vec3 vertD = vec3( float(fragmentXIndex + 1) / hglen, heightmapData.m_Heights[offsetLinearD + dataOffset] / 50000.0f, float(fragmentYIndex + 1) / hglen);

    vertA *= 4;
    vertB *= 4;
    vertC *= 4;
    vertD *= 4;

    vec3 norm = triangleNormal(vertA, vertB, vertC);
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }

    // debug info
    OUT[0].workgroupID = gl_GlobalInvocationID.x;
    OUT[0].coordinates = uvec2(fragmentXIndex, fragmentYIndex);
    OUT[0].pointID = pointID;

    OUT[1].workgroupID = gl_GlobalInvocationID.x;
    OUT[1].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex);
    OUT[1].pointID = pointID;

    OUT[2].workgroupID = gl_GlobalInvocationID.x;
    OUT[2].coordinates = uvec2(fragmentXIndex, fragmentYIndex + 1);
    OUT[2].pointID = pointID;

    OUT[3].workgroupID = gl_WorkGroupID.x;
    OUT[3].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex + 1);
    OUT[3].pointID = pointID;

    OUT[4].workgroupID = gl_WorkGroupID.x;
    OUT[4].coordinates = uvec2(fragmentXIndex + 1, fragmentYIndex);
    OUT[4].pointID = pointID;

    OUT[5].workgroupID = gl_WorkGroupID.x;
    OUT[5].coordinates = uvec2(fragmentXIndex, fragmentYIndex + 1);
    OUT[5].pointID = pointID;


    // triag 1
    OUT[0].meshletID = meshletID;
    OUT[0].wPos = vertA;
    OUT[0].wNormal = norm;

    OUT[1].meshletID = meshletID;
    OUT[1].wPos = vertB;
    OUT[1].wNormal = norm;

    OUT[2].meshletID = meshletID;
    OUT[2].wPos = vertC;
    OUT[2].wNormal = norm;




    norm = triangleNormal(vertD, vertB, vertC);
    if(dot(norm, vec3(0, 1, 0)) < 0){
        norm *= -1;
    }

    // triag 2
    OUT[3].meshletID = meshletID;
    OUT[3].wPos = vertD;
    OUT[3].wNormal = norm;

    OUT[4].meshletID = meshletID;
    OUT[4].wPos = vertB;
    OUT[4].wNormal = norm;

    OUT[5].meshletID = meshletID;
    OUT[5].wPos = vertC;
    OUT[5].wNormal = norm;


    /*
    gl_MeshVerticesEXT[0].gl_Position =  vec4(vertA, float(meshletID));
    gl_MeshVerticesEXT[1].gl_Position = vec4(vertB, float(meshletID + 1));
    gl_MeshVerticesEXT[2].gl_Position =  vec4(vertC, float(meshletID + 8));
    gl_MeshVerticesEXT[3].gl_Position =  vec4(vertD, float(meshletID + 9));
    */


    gl_MeshVerticesEXT[0].gl_Position = PushConstants.transform_matrix * vec4(vertA, 1.0);
    gl_MeshVerticesEXT[1].gl_Position = PushConstants.transform_matrix * vec4(vertB, 1.0);
    gl_MeshVerticesEXT[2].gl_Position = PushConstants.transform_matrix * vec4(vertC, 1.0);
    gl_MeshVerticesEXT[3].gl_Position = PushConstants.transform_matrix * vec4(vertD, 1.0);
    gl_MeshVerticesEXT[4].gl_Position = gl_MeshVerticesEXT[1].gl_Position;
    gl_MeshVerticesEXT[5].gl_Position = gl_MeshVerticesEXT[2].gl_Position;


    gl_PrimitiveTriangleIndicesEXT[0] = uvec3(0, 1, 2);
    gl_PrimitiveTriangleIndicesEXT[1] = uvec3(3, 4, 5);


    gl_MeshPrimitivesEXT[0].gl_PrimitiveID = int(pointID) ;
    gl_MeshPrimitivesEXT[1].gl_PrimitiveID = int(pointID);

}